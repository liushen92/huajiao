# coding: utf-8from model.utils.utils import *import osimport loggingfrom model.utils.constants import *class DataInterface(object):    def __init__(self):        self._user_anchor_behavior = dict()        self._user2id = None        self._anchor2id = None        self._label2id = None    @property    def user2id(self):        if self._user2id is None:            self._user2id = load_dict(os.path.join(tmp_dir, "user_map.txt"))        return self._user2id    @property    def anchor2id(self):        if self._anchor2id is None:            self._anchor2id = load_dict(os.path.join(tmp_dir, "anchor_map.txt"))        return self._anchor2id    @property    def label2id(self):        if self._label2id is None:            self._label2id = load_dict(os.path.join(tmp_dir, "label_map.txt"))        return self._label2id    @property    def user_num(self):        return len(self.user2id)    @property    def anchor_num(self):        return len(self.anchor2id)    @property    def label_num(self):        return len(self._label2id)    @property    def user_anchor_behavior(self):        return self._user_anchor_behavior    def load_data(self, path_to_data, new_data=False):        logging.info("Start reading data.")        if not new_data:            if os.path.isfile(os.path.join(tmp_dir, "user_anchor_behavior")):                self._user_anchor_behavior = pickle_load(os.path.join(tmp_dir, "user_anchor_behavior"))                logging.info("Data loaded.")                return            else:                logging.error("No preprocessed data exists at {}".format(tmp_dir))        i = 0        self._label2id = dict()        with open(os.path.join(data_dir, "label_list")) as f:            for l in f.readlines():                self._label2id[l.strip().split('\t')[0]] = len(self._label2id)        with open(path_to_data) as f:            for l in f.readlines():                tmp = l.strip().split("\t")                user_md5 = tmp[0]                anchor_md5 = tmp[1]                watch_time = int(tmp[2])                praise_num = int(tmp[3])                gift_num = int(tmp[4])                gift_rmb = float(tmp[5])                chat_count = int(tmp[6])                chat_length = int(tmp[7])                labels = []                if len(tmp) == 9:                    labels = map(lambda x: self.label2id[x], tmp[-1].split(','))                self._user2id = dict()                self._anchor2id = dict()                user_id = self._get_id(user_md5, self.user2id)                item_id = self._get_id(anchor_md5, self.anchor2id)                logging.debug("line {}: Parse the line ({}, {}, {})".format(i + 1, user_id, item_id, watch_time))                i += 1                if self._user_anchor_behavior.get(user_id) is None:                    self._user_anchor_behavior[user_id] = dict()                self._user_anchor_behavior[user_id][item_id] = (watch_time, praise_num, gift_num, gift_rmb,                                                                chat_count, chat_length, labels)        pickled_save(self.user_anchor_behavior, os.path.join(tmp_dir, "user_anchor_behavior"))        save_dict(self.user2id, os.path.join(tmp_dir, "user_map.txt"))        save_dict(self.anchor2id, os.path.join(tmp_dir, "anchor_map.txt"))        save_dict(self.label2id, os.path.join(tmp_dir, "label_map.txt"))        logging.info("Data loaded.")    def save_rec_dict(self, recommend_dict, path_to_rec_file):        id2anchor = reverse_dict(self.anchor2id)        id2user = reverse_dict(self.user2id)        id2label = reverse_dict(self.label2id)        with open(path_to_rec_file, 'w') as f:            for user_id in recommend_dict:                f.write(id2user[user_id] + "\t")                for item_id, score in recommend_dict[user_id]:                    f.write(id2anchor[item_id] + ":" + score + " ")                f.write("\n")    def generate_test_data(self, path_to_raw_test, path_to_test_file):        logging.info("Start reading data.")        user_watch_time = dict()        with open(path_to_raw_test) as f:            for l in f.readlines():                user_md5, item_md5, watch_time = l.strip().split("\t")                watch_time = float(watch_time)                if self.user2id.get(user_md5) is None or self.item2id.get(item_md5) is None:                    continue                if user_watch_time.get(self.user2id.get(user_md5)) is None:                    user_watch_time[self.user2id.get(user_md5)] = dict()                user_watch_time[self.user2id.get(user_md5)][self.item2id.get(item_md5)] = watch_time        if len(self.id2item) == 0 or len(self.id2user) == 0:            self.id2item = reverse_dict(self.item2id)            self.id2user = reverse_dict(self.user2id)        with open(path_to_test_file, 'w') as f:            for user_id in user_watch_time:                f.write(self.id2user[user_id] + "\t")                test_list = sorted(list(user_watch_time[user_id].keys()),                                   key=lambda x: user_watch_time[user_id][x],                                   reverse=True)                for item_id in test_list:                    f.write(self.id2item[item_id] + ":" + str(user_watch_time[user_id][item_id]) + " ")                f.write("\n")        logging.info("Data loaded.")    def _get_id(self, md5, map_dict):        _id = map_dict.get(md5)        if _id is None:            _id = len(map_dict)            map_dict[md5] = _id        return _idif __name__ == "__main__":    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(filename)s:%(levelname)s:%(message)s',                        datefmt='%Y-%m-%d %A %H:%M:%S')    data_loader = DataInterface()