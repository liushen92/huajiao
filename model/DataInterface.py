# coding: utf-8import osimport loggingfrom .constants import *from .utils import *class DataInterface(object):    def __init__(self):        self._user_anchor_behavior = dict()        self._user2id = None        self._anchor2id = None        self._label2id = None    @property    def user2id(self):        if self._user2id is None:            if os.path.isfile(os.path.join(tmp_dir, "user_map.txt")):                self._user2id = load_dict(os.path.join(tmp_dir, "user_map.txt"))            else:                self._user2id = dict()                with open(os.path.join(data_dir, "user_list")) as f:                    for l in f.readlines():                        self._user2id[l.strip().split("\t")[0]] = len(self._user2id)                save_dict(self._user2id, os.path.join(tmp_dir, "user_map.txt"))        return self._user2id    @property    def anchor2id(self):        if self._anchor2id is None:            if os.path.isfile(os.path.join(tmp_dir, "anchor_map.txt")):                self._anchor2id = load_dict(os.path.join(tmp_dir, "anchor_map.txt"))            else:                self._anchor2id = dict()                with open(os.path.join(data_dir, "anchor_list")) as f:                    for l in f.readlines():                        self._anchor2id[l.strip().split('\t')[0]] = len(self._anchor2id)                save_dict(self._anchor2id, os.path.join(tmp_dir, "anchor_map.txt"))        return self._anchor2id    @property    def label2id(self):        if self._label2id is None:            if os.path.isfile(os.path.join(tmp_dir, "label_map.txt")):                self._label2id = load_dict(os.path.join(tmp_dir, "label_map.txt"))            else:                self._label2id = dict()                with open(os.path.join(data_dir, "label_list")) as f:                    for l in f.readlines():                        self._label2id[l.strip().split("\t")[0]] = len(self._label2id)                save_dict(self._label2id, os.path.join(tmp_dir, "label_map.txt"))        return self._label2id    @property    def user_num(self):        return len(self.user2id)    @property    def anchor_num(self):        return len(self.anchor2id)    @property    def label_num(self):        return len(self._label2id)    @property    def user_anchor_behavior(self):        return self._user_anchor_behavior    def load_data(self, path_to_data):        logging.info("Start reading data.")        if os.path.isfile(os.path.join(tmp_dir, "user_anchor_behavior")):            self._user_anchor_behavior = pickle_load(os.path.join(tmp_dir, "user_anchor_behavior"))            logging.info("Data loaded.")            return        i = 0        with open(path_to_data, encoding="utf-8") as f:            for l in f.readlines():                tmp = l.strip().split("\t")                user_md5 = tmp[0]                anchor_md5 = tmp[1]                watch_time = int(tmp[2])                praise_num = int(tmp[3])                gift_num = int(tmp[4])                gift_rmb = float(tmp[5])                chat_count = int(tmp[6])                chat_length = int(tmp[7])                labels = []                if len(tmp) == 9:                    labels = list(map(lambda x: self.label2id[x], tmp[-1].split(',')))                user_id = self.user2id[user_md5]                anchor_id = self.anchor2id[anchor_md5]                logging.debug("line {}: Parse the line ({}, {}, {}, {})"                              .format(i + 1, user_id, anchor_id, watch_time, labels))                i += 1                if self._user_anchor_behavior.get(user_id) is None:                    self._user_anchor_behavior[user_id] = dict()                self._user_anchor_behavior[user_id][anchor_id] = (watch_time, praise_num, gift_num, gift_rmb,                                                                  chat_count, chat_length, labels)        pickled_save(self.user_anchor_behavior, os.path.join(tmp_dir, "user_anchor_behavior"))        logging.info("Data loaded.")    def save_rec_dict(self, recommend_dict, path_to_rec_file):        id2anchor = reverse_dict(self.anchor2id)        id2user = reverse_dict(self.user2id)        id2label = reverse_dict(self.label2id)        with open(path_to_rec_file, 'w') as f:            for user_id in recommend_dict:                f.write(id2user[user_id] + "\t")                for anchor_id, score in recommend_dict[user_id]:                    f.write(id2anchor[anchor_id] + ":" + str(score) + " ")                f.write("\n")    def generate_test_data(self, path_to_raw_test, path_to_test_file):        logging.info("Start reading data.")        user_watch_time = dict()        with open(path_to_raw_test) as f:            for l in f.readlines():                tmp = l.strip().split("\t")                user_md5 = tmp[0]                anchor_md5 = tmp[1]                watch_time = int(tmp[2])                praise_num = int(tmp[3])                gift_num = int(tmp[4])                gift_rmb = float(tmp[5])                chat_count = int(tmp[6])                chat_length = int(tmp[7])                labels = []                if len(tmp) == 9:                    labels = list(map(lambda x: self.label2id[x], tmp[-1].split(',')))                if self.user2id.get(user_md5) is None or self.anchor2id.get(anchor_md5) is None:                    continue                if user_watch_time.get(self.user2id.get(user_md5)) is None:                    user_watch_time[self.user2id.get(user_md5)] = dict()                user_watch_time[self.user2id.get(user_md5)][self.anchor2id.get(anchor_md5)] = watch_time        id2anchor = reverse_dict(self.anchor2id)        id2user = reverse_dict(self.user2id)        with open(path_to_test_file, 'w') as f:            for user_id in user_watch_time:                f.write(id2user[user_id] + "\t")                test_list = sorted(list(user_watch_time[user_id].keys()),                                   key=lambda x: user_watch_time[user_id][x],                                   reverse=True)                for anchor_id in test_list:                    f.write(id2anchor[anchor_id] + ":" + str(user_watch_time[user_id][anchor_id]) + " ")                f.write("\n")        logging.info("Data loaded.")